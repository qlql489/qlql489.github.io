<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot获取不到客户端ip问题排查]]></title>
    <url>%2F2022%2F11%2F19%2Fspringboot%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AFip%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[一、现象springboot从2.0.2升级到 2.5.7后线上环境无法通过request.getHeader(“x-forwarded-for”)获取客户端ip地址，测试环境正常，开发环境也异常 二、结论springboot 2.5.7版本中CloudPlatform多了Kubernetes platform的类型识别，如果使用的是内嵌的tomcat，在k8s环境中会自动添加了tomcat的RemoteIpValve，线上环境的httpHeader(x-forwarded-for)只有一个，没有代理ip信息，按RemoteIpValve的逻辑，x-forwarded-for头信息会被删除。 三、排查流程1、抓包看请求与现象dev环境抓包 可以看到抓包中有x-forwarded-for，但是一个内网ip 2、本地调试使用develop分支本地模拟dev环境请求，debug发现可以获取到ip地址 3、搜索springboot丢失x-forwarded-for的原因搜索到文章https://loveyu.org/5951.html 看到了删除header的调用 removeHeader方法，但没有写是哪个类，搜索代码发现是内嵌tomcat的RemoteIpValve类中调用，大致看了下逻辑其中有删除header x-forwarded-for的代码，但打断点debug发现不会走到RemoteIpValve中 4、查看RemoteIpValve的执行逻辑查看上面文章提到的配置：server.forward-headers-strategy 通过搜索发现，是在spring的配置类org.springframework.boot.autoconfigure.web.ServerProperties中 1234/** * Strategy for handling X-Forwarded-* headers. */private ForwardHeadersStrategy forwardHeadersStrategy; get方法会在TomcatWebServerFactoryCustomizer类的getOrDeduceUseForwardHeaders方法中调用 1234567891011121314151617181920212223242526272829303132333435private void customizeRemoteIpValve(ConfigurableTomcatWebServerFactory factory) &#123; Remoteip remoteIpProperties = this.serverProperties.getTomcat().getRemoteip(); String protocolHeader = remoteIpProperties.getProtocolHeader(); String remoteIpHeader = remoteIpProperties.getRemoteIpHeader(); // For back compatibility the valve is also enabled if protocol-header is set if (StringUtils.hasText(protocolHeader) || StringUtils.hasText(remoteIpHeader) || getOrDeduceUseForwardHeaders()) &#123; RemoteIpValve valve = new RemoteIpValve(); valve.setProtocolHeader(StringUtils.hasLength(protocolHeader) ? protocolHeader : &quot;X-Forwarded-Proto&quot;); if (StringUtils.hasLength(remoteIpHeader)) &#123; valve.setRemoteIpHeader(remoteIpHeader); &#125; // The internal proxies default to a list of &quot;safe&quot; internal IP addresses valve.setInternalProxies(remoteIpProperties.getInternalProxies()); try &#123; valve.setHostHeader(remoteIpProperties.getHostHeader()); &#125; catch (NoSuchMethodError ex) &#123; // Avoid failure with war deployments to Tomcat 8.5 before 8.5.44 and // Tomcat 9 before 9.0.23 &#125; valve.setPortHeader(remoteIpProperties.getPortHeader()); valve.setProtocolHeaderHttpsValue(remoteIpProperties.getProtocolHeaderHttpsValue()); // ... so it&apos;s safe to add this valve by default. factory.addEngineValves(valve); &#125;&#125; private boolean getOrDeduceUseForwardHeaders() &#123; if (this.serverProperties.getForwardHeadersStrategy() == null) &#123; CloudPlatform platform = CloudPlatform.getActive(this.environment); return platform != null &amp;&amp; platform.isUsingForwardHeaders(); &#125; return this.serverProperties.getForwardHeadersStrategy().equals(ServerProperties.ForwardHeadersStrategy.NATIVE);&#125; getOrDeduceUseForwardHeaders方法逻辑 1、如果没有配置forwardHeadersStrategy则判断目前的环境 org.springframework.boot.cloud.CloudPlatform#getActive 12345678910public static CloudPlatform getActive(Environment environment) &#123; if (environment != null) &#123; for (CloudPlatform cloudPlatform : values()) &#123; if (cloudPlatform.isActive(environment)) &#123; return cloudPlatform; &#125; &#125; &#125; return null;&#125; CloudPlatform枚举类中可以看到比之前的springboot版本多了KUBERNETES的枚举，也就是在k8s环境CloudPlatform.getActive(this.environment)返回的不为空，isUsingForwardHeaders返回也为true 123public boolean isUsingForwardHeaders() &#123; return true;&#125; 2、如果配置了则判断是否为NATIVE 新版本通过k8s环境判断getOrDeduceUseForwardHeaders方法返回true getOrDeduceUseForwardHeaders返回为true，在customizeRemoteIpValve方法中就会添加RemoteIpValve 5、为什么测试环境没事，dev和线上都有问题通过arthus查看dev和测试环境的调用栈，发现调用栈不同 dev调用栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748`---ts=2022-11-14 20:45:50;thread_name=http-nio-8080-exec-1;id=5b;is_daemon=true;priority=5;TCCL=org.springframework.boot.loader.LaunchedURLClassLoader@3d24753a `---[1.786075ms] org.apache.catalina.valves.RemoteIpValve:invoke() +---[0.54% 0.009643ms ] org.apache.catalina.connector.Request:getRemoteAddr() #613 +---[0.17% 0.002994ms ] org.apache.catalina.connector.Request:getRemoteHost() #614 +---[0.19% 0.003369ms ] org.apache.catalina.connector.Request:getScheme() #615 +---[0.15% 0.002714ms ] org.apache.catalina.connector.Request:isSecure() #616 +---[0.17% 0.003068ms ] org.apache.catalina.connector.Request:getServerName() #617 +---[0.15% 0.002709ms ] org.apache.catalina.valves.RemoteIpValve:isChangeLocalName() #618 +---[0.16% 0.002895ms ] org.apache.catalina.connector.Request:getServerPort() #619 +---[0.22% 0.003994ms ] org.apache.catalina.connector.Request:getLocalPort() #620 +---[0.18% 0.00325ms ] org.apache.catalina.connector.Request:getHeader() #621 +---[0.16% 0.002793ms ] org.apache.catalina.connector.Request:getHeader() #622 +---[0.21% 0.00372ms ] org.apache.catalina.connector.Request:getHeaders() #632 +---[0.18% 0.003182ms ] org.apache.catalina.valves.RemoteIpValve:commaDelimitedListToStringArray() #640 +---[0.14% 0.002488ms ] org.apache.catalina.connector.Request:getHeader() #700 +---[0.13% 0.002356ms ] org.apache.catalina.connector.Request:getHeader() #716 +---[0.28% 0.004932ms ] org.apache.catalina.connector.Request:setAttribute() #736 +---[0.14% 0.002555ms ] org.apache.juli.logging.Log:isDebugEnabled() #738 +---[0.10% 0.001796ms ] org.apache.catalina.connector.Request:getRemoteAddr() #756 +---[0.15% 0.002711ms ] org.apache.catalina.connector.Request:setAttribute() #755 +---[0.13% 0.002321ms ] org.apache.catalina.connector.Request:getRemoteAddr() #758 +---[0.12% 0.002186ms ] org.apache.catalina.connector.Request:setAttribute() #757 +---[0.11% 0.001972ms ] org.apache.catalina.connector.Request:getRemoteHost() #760 +---[0.12% 0.002058ms ] org.apache.catalina.connector.Request:setAttribute() #759 +---[0.19% 0.003334ms ] org.apache.catalina.connector.Request:getProtocol() #762 +---[0.12% 0.00218ms ] org.apache.catalina.connector.Request:setAttribute() #761 +---[0.12% 0.002192ms ] org.apache.catalina.connector.Request:getServerName() #764 +---[0.12% 0.00212ms ] org.apache.catalina.connector.Request:setAttribute() #763 +---[0.11% 0.002021ms ] org.apache.catalina.connector.Request:getServerPort() #766 +---[0.14% 0.002423ms ] org.apache.catalina.connector.Request:setAttribute() #765 +---[0.39% 0.007047ms ] org.apache.catalina.valves.RemoteIpValve:getNext() #769 +---[79.19% 1.414379ms ] org.apache.catalina.Valve:invoke() #769 +---[0.23% 0.00409ms ] org.apache.catalina.connector.Request:setRemoteAddr() #771 +---[0.16% 0.002866ms ] org.apache.catalina.connector.Request:setRemoteHost() #772 +---[0.15% 0.002725ms ] org.apache.catalina.connector.Request:setSecure() #773 +---[0.20% 0.00363ms ] org.apache.catalina.connector.Request:getCoyoteRequest() #774 +---[0.19% 0.003448ms ] org.apache.coyote.Request:scheme() #774 +---[0.14% 0.002545ms ] org.apache.tomcat.util.buf.MessageBytes:setString() #774 +---[0.16% 0.002889ms ] org.apache.catalina.connector.Request:getCoyoteRequest() #775 +---[0.19% 0.00342ms ] org.apache.coyote.Request:serverName() #775 +---[0.17% 0.00297ms ] org.apache.tomcat.util.buf.MessageBytes:setString() #775 +---[0.22% 0.003904ms ] org.apache.catalina.valves.RemoteIpValve:isChangeLocalName() #776 +---[0.20% 0.00363ms ] org.apache.catalina.connector.Request:setServerPort() #779 +---[0.17% 0.003065ms ] org.apache.catalina.connector.Request:setLocalPort() #780 +---[0.16% 0.002877ms ] org.apache.catalina.connector.Request:getCoyoteRequest() #782 +---[0.18% 0.003204ms ] org.apache.coyote.Request:getMimeHeaders() #782 +---[0.22% 0.003937ms ] org.apache.tomcat.util.http.MimeHeaders:removeHeader() #784 `---[0.17% 0.003077ms ] org.apache.tomcat.util.http.MimeHeaders:removeHeader() #790 测试环境调用栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172`---ts=2022-11-14 21:02:40;thread_name=http-nio-8080-exec-5;id=aa;is_daemon=true;priority=5;TCCL=org.springframework.boot.loader.LaunchedURLClassLoader@42f85fa4 `---[100.85578ms] org.apache.catalina.valves.RemoteIpValve:invoke() +---[0.02% 0.016252ms ] org.apache.catalina.connector.Request:getRemoteAddr() #613 +---[0.00% 0.002572ms ] org.apache.catalina.connector.Request:getRemoteHost() #614 +---[0.00% 0.001721ms ] org.apache.catalina.connector.Request:getScheme() #615 +---[0.00% 0.001826ms ] org.apache.catalina.connector.Request:isSecure() #616 +---[0.00% 0.001719ms ] org.apache.catalina.connector.Request:getServerName() #617 +---[0.00% 0.002139ms ] org.apache.catalina.valves.RemoteIpValve:isChangeLocalName() #618 +---[0.00% 0.004452ms ] org.apache.catalina.connector.Request:getServerPort() #619 +---[0.00% 0.002919ms ] org.apache.catalina.connector.Request:getLocalPort() #620 +---[0.00% 0.001888ms ] org.apache.catalina.connector.Request:getHeader() #621 +---[0.00% 0.003649ms ] org.apache.catalina.connector.Request:getHeader() #622 +---[0.00% 0.0024ms ] org.apache.catalina.connector.Request:getHeaders() #632 +---[0.01% 0.011289ms ] org.apache.catalina.valves.RemoteIpValve:commaDelimitedListToStringArray() #640 +---[0.00% 0.001824ms ] org.apache.catalina.connector.Request:setRemoteAddr() #667 +---[0.00% 0.001824ms ] org.apache.catalina.connector.Request:getConnector() #668 +---[0.00% 0.002051ms ] org.apache.catalina.connector.Connector:getEnableLookups() #668 +---[0.00% 0.001576ms ] org.apache.catalina.connector.Request:setRemoteHost() #682 +---[0.00% 0.001515ms ] org.apache.catalina.connector.Request:getCoyoteRequest() #686 +---[0.00% 0.00188ms ] org.apache.coyote.Request:getMimeHeaders() #686 +---[0.00% 0.001862ms ] org.apache.tomcat.util.http.MimeHeaders:removeHeader() #686 +---[0.00% 0.004026ms ] org.apache.tomcat.util.buf.StringUtils:join() #694 +---[0.00% 0.001333ms ] org.apache.catalina.connector.Request:getCoyoteRequest() #695 +---[0.00% 0.001517ms ] org.apache.coyote.Request:getMimeHeaders() #695 +---[0.00% 0.001971ms ] org.apache.tomcat.util.http.MimeHeaders:setValue() #695 +---[0.00% 0.001817ms ] org.apache.tomcat.util.buf.MessageBytes:setString() #695 +---[0.00% 0.00168ms ] org.apache.catalina.connector.Request:getHeader() #700 +---[0.00% 0.003129ms ] org.apache.catalina.valves.RemoteIpValve:isForwardedProtoHeaderValueSecure() #704 +---[0.00% 0.001654ms ] org.apache.catalina.connector.Request:setSecure() #709 +---[0.00% 0.001344ms ] org.apache.catalina.connector.Request:getCoyoteRequest() #710 +---[0.00% 0.002058ms ] org.apache.coyote.Request:scheme() #710 +---[0.00% 0.001186ms ] org.apache.tomcat.util.buf.MessageBytes:setString() #710 +---[0.00% 0.002904ms ] org.apache.catalina.valves.RemoteIpValve:setPorts() #711 +---[0.00% 0.001491ms ] org.apache.catalina.connector.Request:getHeader() #716 +---[0.00% 0.003306ms ] org.apache.tomcat.util.http.parser.Host:parse() #719 +---[0.00% 0.001296ms ] org.apache.catalina.connector.Request:getCoyoteRequest() #725 +---[0.00% 0.001337ms ] org.apache.coyote.Request:serverName() #725 +---[0.00% 0.001271ms ] org.apache.tomcat.util.buf.MessageBytes:setString() #725 +---[0.00% 0.001253ms ] org.apache.catalina.valves.RemoteIpValve:isChangeLocalName() #726 +---[0.00% 0.003314ms ] org.apache.catalina.connector.Request:setAttribute() #736 +---[0.02% 0.015683ms ] org.apache.juli.logging.Log:isDebugEnabled() #738 +---[0.00% 0.00135ms ] org.apache.catalina.connector.Request:getRemoteAddr() #756 +---[0.00% 0.001719ms ] org.apache.catalina.connector.Request:setAttribute() #755 +---[0.00% 0.001249ms ] org.apache.catalina.connector.Request:getRemoteAddr() #758 +---[0.00% 0.001294ms ] org.apache.catalina.connector.Request:setAttribute() #757 +---[0.00% 0.00128ms ] org.apache.catalina.connector.Request:getRemoteHost() #760 +---[0.00% 0.001485ms ] org.apache.catalina.connector.Request:setAttribute() #759 +---[0.00% 0.002571ms ] org.apache.catalina.connector.Request:getProtocol() #762 +---[0.00% 0.001857ms ] org.apache.catalina.connector.Request:setAttribute() #761 +---[0.01% 0.008126ms ] org.apache.catalina.connector.Request:getServerName() #764 +---[0.00% 0.001972ms ] org.apache.catalina.connector.Request:setAttribute() #763 +---[0.00% 0.001452ms ] org.apache.catalina.connector.Request:getServerPort() #766 +---[0.00% 0.001782ms ] org.apache.catalina.connector.Request:setAttribute() #765 +---[0.00% 0.001442ms ] org.apache.catalina.valves.RemoteIpValve:getNext() #769 +---[99.65% 100.500217ms ] org.apache.catalina.Valve:invoke() #769 +---[0.00% 0.002653ms ] org.apache.catalina.connector.Request:setRemoteAddr() #771 +---[0.00% 0.001491ms ] org.apache.catalina.connector.Request:setRemoteHost() #772 +---[0.00% 0.00171ms ] org.apache.catalina.connector.Request:setSecure() #773 +---[0.00% 0.001662ms ] org.apache.catalina.connector.Request:getCoyoteRequest() #774 +---[0.00% 0.00229ms ] org.apache.coyote.Request:scheme() #774 +---[0.00% 0.001822ms ] org.apache.tomcat.util.buf.MessageBytes:setString() #774 +---[0.00% 0.00142ms ] org.apache.catalina.connector.Request:getCoyoteRequest() #775 +---[0.00% 0.002272ms ] org.apache.coyote.Request:serverName() #775 +---[0.00% 0.001255ms ] org.apache.tomcat.util.buf.MessageBytes:setString() #775 +---[0.00% 0.002824ms ] org.apache.catalina.valves.RemoteIpValve:isChangeLocalName() #776 +---[0.00% 0.001433ms ] org.apache.catalina.connector.Request:setServerPort() #779 +---[0.00% 0.001558ms ] org.apache.catalina.connector.Request:setLocalPort() #780 +---[0.00% 0.001666ms ] org.apache.catalina.connector.Request:getCoyoteRequest() #782 +---[0.00% 0.001526ms ] org.apache.coyote.Request:getMimeHeaders() #782 +---[0.00% 0.002167ms ] org.apache.tomcat.util.http.MimeHeaders:removeHeader() #784 +---[0.00% 0.002147ms ] org.apache.tomcat.util.http.MimeHeaders:setValue() #792 `---[0.00% 0.001765ms ] org.apache.tomcat.util.buf.MessageBytes:setString() #792 对比代码发现dev环境的确执行了删除header的操作 仔细探究RemoteIpValve代码逻辑 和目前问题相关的大致功能为：解析X-Forwarded-for请求头，将其中的远端地址设置到RemoteAddr中 1234567简单解释X-Forwarded-For的作用例如真正的用户客户端是Client1，通过代理服务器proxy1，proxy2，到达服务器，在Tomcat中执行获取客户端地址的方法：request.getRemoteAddr，获得的IP地址是proxy2的，也就是负载均衡的地址；而如果你想要获取Client1的地址，也是可以获取到的，就是通过X-Forwarded-For字段；X-Forwarded-For:简称XFF头，它代表客户端，只有在通过了HTTP 代理或者负载均衡服务器时才会添加该项。X-Forwarded-For内置在Http协议头中，刚刚的场景X-Forwarded-For取值为：client1, proxy1, proxy2 具体逻辑为： 对于列表中的每个ip，如果属于内网地址则跳过，否则将此ip设置为远程ip，停止循环 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//最近一跳代理地址final String originalRemoteAddr = request.getRemoteAddr();...//X-Forwarded-For头信息final String originalRemoteIpHeader = request.getHeader(remoteIpHeader);//最近一跳代理地址是否为内网// 内网正则判断为 Pattern internalProxies = Pattern.compile( "10\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|" + "192\\.168\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|" + "169\\.254\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|" + "127\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|" + "172\\.1[6-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|" + "172\\.2[0-9]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|" + "172\\.3[0-1]&#123;1&#125;\\.\\d&#123;1,3&#125;\\.\\d&#123;1,3&#125;|" + "0:0:0:0:0:0:0:1|::1");//originalRemoteAddr 所有环境都为内网地址，返回trueboolean isInternal = internalProxies != null &amp;&amp; internalProxies.matcher(originalRemoteAddr).matches();//trustedProxies为空if (isInternal || (trustedProxies != null &amp;&amp; trustedProxies.matcher(originalRemoteAddr).matches())) &#123; String remoteIp = null; Deque&lt;String&gt; proxiesHeaderValue = new LinkedList&lt;&gt;(); StringBuilder concatRemoteIpHeaderValue = new StringBuilder(); for (Enumeration&lt;String&gt; e = request.getHeaders(remoteIpHeader); e.hasMoreElements();) &#123; if (concatRemoteIpHeaderValue.length() &gt; 0) &#123; concatRemoteIpHeaderValue.append(", "); &#125; concatRemoteIpHeaderValue.append(e.nextElement()); &#125; //X-Forwarded-For内的地址转换为数组 String[] remoteIpHeaderValue = commaDelimitedListToStringArray(concatRemoteIpHeaderValue.toString()); int idx; if (!isInternal) &#123; proxiesHeaderValue.addFirst(originalRemoteAddr); &#125; //从最后的地址循环 for (idx = remoteIpHeaderValue.length - 1; idx &gt;= 0; idx--) &#123; String currentRemoteIp = remoteIpHeaderValue[idx]; remoteIp = currentRemoteIp; //如果是内网地址则跳过 if (internalProxies !=null &amp;&amp; internalProxies.matcher(currentRemoteIp).matches()) &#123; //trustedProxies目前配置为空 &#125; else if (trustedProxies != null &amp;&amp; trustedProxies.matcher(currentRemoteIp).matches()) &#123; proxiesHeaderValue.addFirst(currentRemoteIp); &#125; else &#123; //找到第一个不是内网地址的idx，但如果只有一个地址，则idx会变成负数 idx--; break; &#125; &#125; //重新构建客户端地址的list，但idx必须不小于0 LinkedList&lt;String&gt; newRemoteIpHeaderValue = new LinkedList&lt;&gt;(); for (; idx &gt;= 0; idx--) &#123; String currentRemoteIp = remoteIpHeaderValue[idx]; newRemoteIpHeaderValue.addFirst(currentRemoteIp); &#125; ... //如果newRemoteIpHeaderValue为空则删除X-Forwarded-For if (newRemoteIpHeaderValue.size() == 0) &#123; request.getCoyoteRequest().getMimeHeaders().removeHeader(remoteIpHeader); &#125; 总结一下逻辑 1X-Forwarded-For中的地址集合从后往前取，在至少有两个地址并且，最后的地址是内网地址的情况下不会删除X-Forwarded-For请求头 看一下dev、test、线上的数据 123456//test环境 172.31.0.203为内网地址X-Forwarded-For: 203.187.160.86, 100.117.125.137, 172.31.0.203//dev环境172.30.1.118为内网地址X-Forwarded-For: 172.30.1.118//线上环境 117.136.68.19为外网地址，但只有一个ip，没有代理的地址X-Forwarded-For: 117.136.68.19 所以dev和线上会被删去请求头 处理在wb-base-component-starter中添加公共配置 12server: forward-headers-strategy: none 不加载tomcat的RemoteIpValve]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>问题排查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TransmittableThreadLocal的错误用法]]></title>
    <url>%2F2020%2F08%2F10%2FTransmittableThreadLocal%E7%9A%84%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言ThreadLocal能够在单个线程中传递参数，使用可以用在系统参数的传递或者在链路跟踪中传递trace相关信息，需要说明的是单单使用ThreadLocal是不会出现ThreadLocal值线程共享的，但仅仅使用ThreadLocal还不够，如果代码中有使用异步，ThreadLocal就无能为力了，这时可以使用JDK自带的InheritableThreadLocal，这次ThreadLocal变量线程共享，就是因为使用了InheritableThreadLocal。 我们的项目使用springboot构建，想使用ThreadLocal来完成透传系统参数，这样所有接口和方法都不要显式的传递次参数，刚刚说到ThreadLocal无法解决异步传递问题，InheritableThreadLocal也只能解决新建线程的情况，无法在线程池的场景中使用，具体原因下次分析，经过调研我们使用阿里开源的TransmittableThreadLocal 示例我们先来看这个例子： 1234567891011121314151617181920212223242526public class TransmittableThreadLocalUtil &#123; private static Logger logger = LoggerFactory.getLogger(TransmittableThreadLocalUtil.class); private static final TransmittableThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocal = new TransmittableThreadLocal() &#123; @Override protected Object initialValue() &#123; return new HashMap(4); &#125; &#125;; public static &lt;T&gt; T get(String key) &#123; logger.info("get &#123;&#125;",key); Map map = (Map)threadLocal.get(); return (T)map.get(key); &#125; public static void set(String key, Object value) &#123; Map map = (Map)threadLocal.get(); map.put(key, value); &#125; public static &lt;T&gt; T remove(String key) &#123; Map map = (Map)threadLocal.get(); return (T)map.remove(key); &#125; 使用阿里的TransmittableThreadLocal封装了一个工具类，初始化一个map，有get、set、remove方法，其他方法省略。 123456789@GetMapping("/testLocal2")public void test2()&#123; logger.info("testLocal2 get "+ TransmittableThreadLocalUtil.get("test"));&#125;@GetMapping("/testLocal3")public void test3()&#123; TransmittableThreadLocalUtil.set("test","200");&#125; 两个接口，一个设置test为200，另一个方法获取，springboot默认使用tomcat作为容器，我们知道tomcat在处理请求时使用了线程池，理论上2个接口的调用不会是同一个线程，我们看log输出可以确认： 122020-08-09 22:59:36.765 INFO 86354 --- [nio-8080-exec-1] c.j.controller.ThreadLocalController : testLocal3 test set 2002020-08-09 22:59:37.755 INFO 86354 --- [nio-8080-exec-2] c.j.controller.ThreadLocalController : testLocal2 get 200 先调用了/testLocal3接口线程名称是nio-8080-exec-2，再调用了/testLocal2，线程名称是nio-8080-exec-1，是两个线程 但是通过log可以看到第二个线程居然取到了第一个线程设置的ThreadLocal变量，这是怎么回事？ThreadLocal不是线程隔离的吗？ 上面只是用一个小例子帮助大家理解，实际中我们使用拦截器在方法调用前获取系统参数放入ThreadLocal中，在调用结束时清理ThreadLocal变量，但因为同样有上面例子中的问题，我们的一此请求没结束时可能ThreadLocal中的值就被别的线程清理的，导致业务异常。 原因这到底是什么原因导致的呢，在翻看了TransmittableThreadLocal的源码以及项目中的使用方式后找到了原因。 TransmittableThreadLocal继承自jdk的InheritableThreadLocal，而InheritableThreadLocal的原理是父线程创建子线程时会将父线程的ThreadLocalMap复制到子线程中，这个复制是引用复制，也就是说子线程可以修改父线程ThreadLocal中的变量，但这也解释不了为什么ThreadLoal会线程共享，tomcat线程池中的线程都是子线程啊，那只可能是父线程出现了问题，再看一下项目代码，找到了原因。 因为在service的静态变量中使用了TransmittableThreadLocalUtil的get方法初始化了那个map，而springboot在加载service时使用的是main主线程，是所有线程的父线程，导致所有的子线程通过TransmittableThreadLocal获取的Map是同一个引用，当然是线程共享了！ 例子中的service示例： 12345678910@Servicepublic class TestService &#123; //静态变量的调用 private String value = TransmittableThreadLocalUtil.get("test"); public void testMethod()&#123; &#125;&#125; get方法中有log，再看一眼启动log 1232020-08-09 22:59:24.104 INFO 86354 --- [ main] o.s.web.context.ContextLoader : Root WebApplicationContext: initialization completed in 2164 ms2020-08-09 22:59:24.202 INFO 86354 --- [ main] c.j.util.TransmittableThreadLocalUtil : get test2020-08-09 22:59:24.808 INFO 86354 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 日志第二行，main线程调用了TransmittableThreadLocalUtil，确定了推断。 其中一种解决方式是在TransmittableThreadLocalUtil的初始化TransmittableThreadLocal对象时复写childValue方法 12345678910111213private static final TransmittableThreadLocal&lt;Map&lt;String, Object&gt;&gt; threadLocal = new TransmittableThreadLocal() &#123; @Override protected Object initialValue() &#123; return new HashMap(4); &#125; @Override protected Object childValue(Object parentValue) &#123; if(parentValue instanceof Map)&#123; return new HashMap&lt;&gt;((Map)parentValue); &#125; return parentValue; &#125; &#125;; 总结1、ThreadLocal不会出现线程间共享的情况。 2、InheritableThreadLocal的原理是新建子线程时将父线程ThreadLocal复制到子线程中，是引用复制，会导致父子线程都能操作那个引用。 3、问题不是TransmittableThreadLocal引起的，是因为错误使用了InheritableThreadLocal，TransmittableThreadLocal只是继承自InheritableThreadLocal。 为什么复写childValue方法就可以解决呢，ThreadLocal有没有别的坑，InheritableThreadLocal以及ThreadLocal中相关的源码是如何处理的呢，期待下一篇吧~]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS原理解析（三、condition原理）]]></title>
    <url>%2F2020%2F03%2F01%2FAQS%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81condition%E5%8E%9F%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[condition的作用condition的使用场景其实很多，涉及到条件判断的并发场景都可以用到，比如： 阻塞队列的ArrayBlockingQueue中做队列满和空的条件判断 CyclicBarrier中做阻塞与唤醒所有线程的判断 DelayQueue中的阻塞获取队列数据的判断 线程池ThreadPoolExecutor中awaitTermination方法的条件判断 condition怎么用呢？ 在使用synchronized时我们可以使用wait()、notify()、notifyAll()方法来调度线程，而condition提供了类似的方法：wait(),signal(),signalAll的功能，并且能够更加精细的控制等待的范围，像上面所说，jdk中使用了很多ReentrantLock和condition的配合来实现线程调度 我们看一个conditon最常见的使用方式：生产消费者的模型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public class ConditionTest &#123; LinkedList&lt;String&gt; lists = new LinkedList&lt;&gt;(); Lock lock = new ReentrantLock(); //集合是否满的条件判断 Condition fullCondition = lock.newCondition(); //集合是否空的条件判断 Condition emptyCondition = lock.newCondition(); //生产者 private void product()&#123; lock.lock(); try &#123; //假如集合大小为10 while (lists.size() == 10)&#123; System.out.println(&quot;list is full&quot;); fullCondition.await(); &#125; //生产一个5位的随机字符串 String randomString = getRandomString(5); lists.add(randomString); System.out.println(String.format(&quot;product %s size %d %s&quot;,randomString,lists.size(),Thread.currentThread().getName())); //通知消费者可以消费了 emptyCondition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; //消费者 private String consume()&#123; lock.lock(); try&#123; while (lists.size() == 0)&#123; System.out.println(&quot;list is empty&quot;); emptyCondition.await(); &#125; String first = lists.removeFirst(); //通知生产者可以生产了 fullCondition.signalAll(); return first; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; return null; &#125; /** * 生成随机字符串 * @param length * @return */ public static String getRandomString(int length)&#123; String str=&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;; Random random=new Random(); StringBuffer sb=new StringBuffer(); for(int i=0;i&lt;length;i++)&#123; int number=random.nextInt(62); sb.append(str.charAt(number)); &#125; return sb.toString(); &#125; public static void main(String[] args) &#123; ConditionTest test = new ConditionTest(); ExecutorService executorService = Executors.newCachedThreadPool(); //线程个数控制消费的快还是生产的快 for(int i = 0;i&lt;2;i++)&#123; executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName()); while (true)&#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; test.product(); &#125; &#125;); &#125; for(int k = 0;k&lt;1;k++)&#123; executorService.submit(()-&gt;&#123; System.out.println(&quot;cousumestart&quot;); while (true) &#123; try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; String consume = test.consume(); System.out.println(&quot;consume &quot; + consume+ &quot; &quot;+Thread.currentThread().getName() ); &#125; &#125;); &#125; //等待输入，阻塞主线程不退出 try &#123; new BufferedReader(new InputStreamReader(System.in)).readLine(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 12345678910111213141516171819//部分输出日志product qeV0r size 7 pool-1-thread-1product xEUkA size 8 pool-1-thread-2consume P5Je1 pool-1-thread-3product rQS1D size 8 pool-1-thread-1product QcEtf size 9 pool-1-thread-2consume 2q7Fc pool-1-thread-3product Z5rBg size 9 pool-1-thread-1consume UBxBD pool-1-thread-3product Tr5q2 size 9 pool-1-thread-2product HXBdE size 10 pool-1-thread-1list is fullconsume aYDNR pool-1-thread-3product ukjnk size 10 pool-1-thread-2list is fullconsume LBEdA pool-1-thread-3product iK28H size 10 pool-1-thread-2list is fulllist is full 可以看到生产者线程有2个，消费者线程有1个，生产和消费的速度相同，用Thread.sleep控制，生产速度大于消费速度，最后集合元素到10个的时候生产者调用fullCondition.await();阻塞，只有消费者消费后通过fullCondition.signalAll();通知生产者继续生产 同理添加消费者线程数，使消费的速度快与生产，则集合为空时会调用emptyCondition.await();阻塞，生产者生产后回调用emptyCondition.signalAll();通知消费者继续生产 相较于对象的wait()、notifyAll()方法不同的条件分开判断，颗粒度更小一些，唤醒的线程范围更精准 再看一下ArrayBlockingQueue的一个例子，在一段时间内阻塞获取队列数据，取不到则返回空： 12345678910111213141516public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) &#123; if (nanos &lt;= 0) return null; //notEmpty 是lock new出来的一个condition nanos = notEmpty.awaitNanos(nanos); &#125; return dequeue(); &#125; finally &#123; lock.unlock(); &#125; &#125; condition的使用场景还多，下面我们就一起看看condition的实现原理吧，首先condition需要在AbstractQueuedSynchronizer实现类的 condition原理解析我们知道AQS中维护了一个队列来控制线程的执行，condition中使用了另一个等待队列来实现条件的判断，condition必须在aqs的acquire获取锁后使用，调用condition.await()方法将添加一个node到条件队列中，在调用signal()或signalAll()后将此节点移出condition的等待队列放到锁的等待队列中去竞争锁，取到锁后继续执行后续逻辑。 condition有以下几个方法 123456789101112131415//将等待时间最长的线程从condition等待队列放到锁的等待队列中public final void signal()//将所有等待线程从condition等待队列放到锁的等待队列中public final void signalAll()//condition的等待方法public final void await() throws InterruptedException //不可中断的waitpublic final void awaitUninterruptibly()//几个有时间参数的wait方法public final long awaitNanos(long nanosTimeout) throws InterruptedExceptionpublic final boolean awaitUntil(Date deadline) throws InterruptedExceptionpublic final boolean await(long time, TimeUnit unit) throws InterruptedException 先看一下最主要的await方法AbstractQueuedSynchronizer.ConditionObject#await() 123456789101112131415161718192021222324public final void await() throws InterruptedException &#123; //如果当前线程被中断了抛出InterruptedException if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter();//（1） int savedState = fullyRelease(node);//(2) int interruptMode = 0; while (!isOnSyncQueue(node)) &#123;//(3) //挂起线程 LockSupport.park(this); //中断情况的判断 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; //被唤醒后去抢锁，抢到后继续执行 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); //如果阻塞中发生了中断，则抛出异常 if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; （1）addConditionWaiter在condition等待队列尾部加入一个节点 123456789101112131415161718private Node addConditionWaiter() &#123; Node t = lastWaiter; // 如果最后一个节点不是condition状态（被取消状态）被取消状态是在fullyReleas方法中产生的 if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; //从头节点开始将被取消或者超时的节点移出队列 unlinkCancelledWaiters(); t = lastWaiter; &#125; Node node = new Node(Thread.currentThread(), Node.CONDITION); //队列为空的情况 if (t == null) firstWaiter = node; else //插入尾节点 t.nextWaiter = node; lastWaiter = node; return node; &#125; （2）fullyRelease能调用wait方法说明已经获取到锁了，fullyRelease方法就是提前调用解锁方法，将自己从lock的队列中移出，并返回当前节点的状态savedState，这里如果释放失败说明当前线程不在持有锁，状态错误，将节点设置成CANCELLED状态 123456789101112131415final int fullyRelease(Node node) &#123; boolean failed = true; try &#123; int savedState = getState(); if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) node.waitStatus = Node.CANCELLED; &#125;&#125; release方法调用tryRelease释放锁并唤醒首节点，在ReentrantLock的实现中tryRelease会判断当前线程是否获取锁，所以在lock方法范围内使用condition会报IllegalMonitorStateException异常 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; （3）isOnSyncQueue回到await方法，循环调用isOnSyncQueue判断是否在锁的等待队列中(注意不是condition的等待队列)，不在锁的等待队列中则调用LockSupport.park(this)挂起线程。 12345678final boolean isOnSyncQueue(Node node) &#123; if (node.waitStatus == Node.CONDITION || node.prev == null) return false; if (node.next != null) // If has successor, it must be on queue return true; return findNodeFromTail(node); &#125; awaitNanos方法大致逻辑和await相同，就是多了一个时间的判断 123456789101112131415161718192021222324252627282930public final long awaitNanos(long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); final long deadline = System.nanoTime() + nanosTimeout; int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; //如果时间小于0，直接从condition队列 if (nanosTimeout &lt;= 0L) &#123; transferAfterCancelledWait(node); break; &#125; //如果大于自旋的阈值则使用parkNanos设置线程挂起的时间，否则继续自旋 if (nanosTimeout &gt;= spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; nanosTimeout = deadline - System.nanoTime(); &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode); return deadline - System.nanoTime();&#125; signal()方法signal的作用是将condition队列中等待时间最长的node转移到锁队列末尾，去重新抢锁123456789public final void signal() &#123; //有不同的实现，ReentrantLock中是判断持有锁的是否当前线程 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);&#125; doSignal将condition中等待时间最长的节点调用transferForSignal方法放到锁队列中，循环调用是要寻找第一个不是cancelled状态的节点 123456789 private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125; doSignalAlldoSignalAll是将所有等待队列中的节点放到锁队列末尾12345678910 private void doSignalAll(Node first) &#123; lastWaiter = firstWaiter = null; do &#123; Node next = first.nextWaiter; first.nextWaiter = null; transferForSignal(first); first = next; &#125; while (first != null);&#125; transferForSignal1234567891011121314151617181920final boolean transferForSignal(Node node) &#123; //cas设置节点为0状态，如果失败说明节点已经被取消了 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; /* * Splice onto queue and try to set waitStatus of predecessor to * indicate that thread is (probably) waiting. If cancelled or * attempt to set waitStatus fails, wake up to resync (in which * case the waitStatus can be transiently and harmlessly wrong). */ //添加到锁队列中 Node p = enq(node); int ws = p.waitStatus; //cancelled状态或者设置SIGNAL状态失败则唤醒此线程 if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125; condition中有很多线程与中断的细节处理，有兴趣的可以自己去看看源码 总结一下： condition必须使用在lock中 condition提供了类似object.wait和notify的通信机制，但支持多个条件队列，使用上更灵活 condition的原理流程如下 线程1获取锁 线程1调用condition.await()进入condition等待队列并阻塞，释放锁给别的线程 线程2获取锁，调用condition.signal，将condition等待队列中的线程1所在的node放在锁的等待队列中竞争锁]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS原理解析（二、共享模式）]]></title>
    <url>%2F2018%2F11%2F18%2FAQS%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一篇介绍了AQS独占模式的原理，参考链接AQS原理解析（一），这篇介绍一下AQS的共享模式如何实现的。 共享模式可以做什么java concurrent包中的很多阻塞类可以一次控制多个线程的挂起和唤醒，比如Semaphore、CountDownLatch,他们内部都继承了AQS并实现了tryAcquireShared,tryReleaseShared方法 共享模式逻辑线程调用acquireShared方法获取锁如果失败则创建共享类型的节点放入FIFO队列，等待唤醒有线程释放锁后唤醒队列最前端的节点，然后唤醒所有后面的共享节点 AQS acquireShared方法acquireShared方法是AQS共享模式的入口 12345678910111213141516/** * Acquires in shared mode, ignoring interrupts. Implemented by * first invoking at least once &#123;@link #tryAcquireShared&#125;, * returning on success. Otherwise the thread is queued, possibly * repeatedly blocking and unblocking, invoking &#123;@link * #tryAcquireShared&#125; until success. * * @param arg the acquire argument. This value is conveyed to * &#123;@link #tryAcquireShared&#125; but is otherwise uninterpreted * and can represent anything you like. */public final void acquireShared(int arg) &#123; //获取共享锁，小于0则放入队列，挂起线程 if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 在调用tryAcquireShared小于零后调用doAcquireShared doAcquireShared这个方法和独占模式的acquireQueued方法差不多，流程就是 在队列尾部添加共享模式节点 前一个节点如果是head并且tryAcquireShared&gt;=0则替换当前节点为head,并唤醒后面所有共享模式节点 如果前一个节点不是head，则挂起当前线程 123456789101112131415161718192021222324252627282930313233343536/** * Acquires in shared uninterruptible mode. * @param arg the acquire argument */private void doAcquireShared(int arg) &#123; //和独占模式相同，在尾部添加节点，不过是设置成共享模式 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取前一个节点 final Node p = node.predecessor(); if (p == head) &#123; //尝试获取共享锁 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; //和独占模式不同的地方，会唤醒后面的共享节点 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; //挂起，具体可以看上一篇 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; setHeadAndPropagate方法1234567891011121314151617181920212223/** * Sets head of queue, and checks if successor may be waiting * in shared mode, if so propagating if either propagate &gt; 0 or * PROPAGATE status was set. * * @param node the node * @param propagate the return value from a tryAcquireShared */private void setHeadAndPropagate(Node node, int propagate) &#123; //记录当前头结点 Node h = head; // Record old head for check below //把当前获取到锁的节点设置为头结点 setHead(node); //propagate大于0表示后面的节点也需要唤醒 // h.waitStatus &lt; 0 表示节点是可唤醒状态 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; //后继节点为空或者是共享模式则唤醒 if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; doReleaseShared 唤醒操作123456789101112131415161718192021222324252627282930/** * Release action for shared mode -- signals successor and ensures * propagation. (Note: For exclusive mode, release just amounts * to calling unparkSuccessor of head if it needs signal.) */private void doReleaseShared() &#123; for (;;) &#123; //从头节点开始 Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; //是需要被唤醒的状态 if (ws == Node.SIGNAL) &#123; //CAS方式做并发控制，设置状态为0 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; //唤醒这个节点 unparkSuccessor(h); &#125; //不需要唤醒，则CAS设置状态为PROPAGATE，继续循环 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; &#125; //头结点没有改变，则设置成功，退出循环 if (h == head) break; &#125;&#125; 可以看出，共享模式与独占模式最大的不同就是，共享模式唤醒第一个节点后会迭代唤醒后面所有的共享节点。 只看原理可能有些抽象，以CountDownLatch为例，讲一下具体实现 CountDownLatchCountDownLatch的作用类似起跑线，初始时可以设置线程个数。 1CountDownLatch countDown = new CountDownLatch(3); CountDownLatch有两个方法 countDown 计数减一 await 线程挂起 使用场景： 比如在多线程任务中，所有任务都完成了才能继续往下执行 比如模拟并发场景，所有任务在一个地方等待，直到个数满足了一起执行。 CountDownLatch内部同步器的实现12345678910111213141516171819202122232425262728293031323334353637383940414243private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; //初始个数 Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125; //个数为0返回1，否则返回-1 protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; protected boolean tryReleaseShared(int releases) &#123; //cas方式计数减一 for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125; &#125; //初始化方法 public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count); &#125; //可中断方式获取锁，与acquireShared原理一样，额外加入了中断判断 public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; //释放锁，计数器减一 public void countDown() &#123; sync.releaseShared(1); &#125; 我们可以看到CountDownLatch的处理逻辑 多个线程调用await方法，将共享模式节点加入到队列中，线程挂起 有线程调用countDown(),尝试释放锁，计数器减一，但只有count为0时才能执行doReleaseShared方法，唤醒后面所有的共享节点，所有挂起线程一起开始执行。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS原理解析（一）]]></title>
    <url>%2F2018%2F10%2F28%2FAQS%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[AQS是什么java concurrent包中有很多阻塞类如：ReentrantLock、ReentrantReadWriteLock、CountDownLatch、Semaphore、Synchronous、FutureTask等，他们的底层都是根据aqs构建的，它可以说是java多线程编程最底层核心的抽象类。既然这么重要，我们就来看看它底层原理到底是什么。 aqs全称AbstractQueuedSynchronizer，它作为抽象类无法单独使用，需要有具体实现，不同的实现中自己定义什么状态意味着获取或者被释放 AQS的原理是什么AQS内部维护一个先进先出（FIFO）的等待队列叫做CLH队列，当一个线程来请求资源时，AQS通过状态判断是否能获取资源，如果不能获取，则挂起这个线程，和状态一起封装成一个Node节点放在队尾，等待前面的线程释放资源好唤醒自己，所以谁先请求的谁最先获得机会唤醒,当然新线程可能加塞提前获取资源，在源码解析可以看到原因 AQS分独占和共享两种方式，独占模式，只有一个线程可以获得锁，比如ReentrantLock，共享模式下可以允许多个线程同时获取锁，比如CountDownLatch使用的就是共享方式， 源码解析AQS的子类需要实现的方法 123456789101112131415161718192021222324//独占方式获取资源protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125;//独占释放资源protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125;//共享获取资源protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125;//共享释放资源protected boolean tryReleaseShared(int arg) &#123; throw new UnsupportedOperationException();&#125;//是否独占protected boolean isHeldExclusively() &#123; throw new UnsupportedOperationException();&#125; 可以看到，子类调用这些方法如果没有实现的话会抛异常，当然也不是所有方法都要实现，找自己需要的实现就可以了。 为了更好的理解先实现一个最简单的锁,只需要实现tryAcquire和tryRelease方法即可 1234567891011121314151617181920212223242526272829303132333435363738public class TestLock &#123; private Sync sync = new Sync(); //加锁 public void lock()&#123; sync.acquire(1); &#125; //解锁 public void unLock()&#123; sync.release(1); &#125; public static class Sync extends AbstractQueuedSynchronizer &#123; @Override protected boolean tryAcquire(int arg) &#123; assert arg == 1; //cas将状态从0设为1，如何不为0则失败 if(compareAndSetState(0,1))&#123; return true; &#125; return false; &#125; @Override protected boolean tryRelease(int arg) &#123; assert arg == 1; if(getState() == 0)&#123; throw new IllegalMonitorStateException(); &#125; //将状态设为0 setState(0); return true; &#125; &#125;&#125; 再来写一个并发场景，简单的加法，先获取前值，用sleep模拟方法执行时间比较长,然后累加 1234567891011121314151617181920212223242526272829303132333435363738public static void main(String[] args) &#123; final AddCount count = new AddCount(); ExecutorService executorService = Executors.newCachedThreadPool(); for(int i = 0;i&lt;3;i++)&#123; executorService.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; count.add(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; public static class AddCount&#123; private int countTotle = 0; public void add(int count) throws InterruptedException &#123; int tmp = this.countTotle; Thread.sleep(100L); this.countTotle = tmp+count; System.out.println(this.countTotle); &#125; &#125; //输出 100 100 100 在add方法加上自定义的的锁 12345678910111213141516171819202122232425public static void main(String[] args) &#123; final AddCount count = new AddCount(); final TestLock testLock = new TestLock(); ExecutorService executorService = Executors.newCachedThreadPool(); for(int i = 0;i&lt;3;i++)&#123; executorService.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; testLock.lock(); count.add(100); testLock.unLock(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; //输出 100 200 300 根据这个简单的例子，我们来看一下源码中是怎么实现的 acquirelock方法首先调用的是AQS的acquire方法 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; 它会调用tryAcquire尝试去取锁，如果没有取到的话调用addWaiter将Node放入队尾，同样也使用CAS的方式，AQS中有大量CAS的使用，不了解CAS的可以看浅析乐观锁、悲观锁与CAS 这里有新的线程在执行第一个判断!tryAcquire(arg)时，如果刚好有线程释放锁，那新的线程很有可能插队直接获取到锁，也就是有队列也无法公平的原因。 1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; 在尾部添加node，将node双向关联，如果成功则直接返回，这里有一个问题，在设置队尾的时候，没有并发控制，有另一个线程也来设置，就只会有一个线程成功，没成功的线程或者队尾为空则执行enq方法。 enq方法123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; 这里看到如果tail是null,则cas设置head为一个新节点,也就是说第一个入队的节点head和tail是相同的。如果队尾不为空，则用cas加自旋的方式放入队尾。 Node对象node对象封装了状态和请求的线程以及前后节点的地址 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static final class Node &#123; //共享节点 static final Node SHARED = new Node(); //非共享节点 static final Node EXCLUSIVE = null; //取消状态（因超时或中断） static final int CANCELLED = 1; //等待唤醒 static final int SIGNAL = -1; //等待条件 static final int CONDITION = -2; //对应共享类型释放资源时，传播唤醒线程状态 static final int PROPAGATE = -3; //当前状态 volatile int waitStatus; //前一个节点 volatile Node prev; //下一个节点 volatile Node next; //请求的线程 volatile Thread thread; Node nextWaiter; final boolean isShared() &#123; return nextWaiter == SHARED; &#125; //获取前一个节点，为空则抛空指针异常 final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125; &#125; 没有使用condition，node常用的状态有 0 新建状态和 -1 挂起状态 acquireQueued再看一下acquireQueued方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取前一个节点 final Node p = node.predecessor(); //如果前一个节点是head,并且能获取锁，则将当前节点设置为head if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; //判断前面节点的状态，中断当前线程 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) //失败了设置成取消状态 cancelAcquire(node); &#125; &#125; private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; //如果前一个节点已经是等待状态，可以安全park if (ws == Node.SIGNAL) return true; //如何前一个节点是取消状态了，则一直往前取，去掉取消状态的节点，直到状态不为取消状态的节点 if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //ws必须是0或-3才会走这里，cas设置成-1待唤醒状态 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false; &#125; //中断当前线程 private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted(); &#125; 这里的主要逻辑就是将新加入的节点设置为待唤醒状态，进入队列的节点都进入中断状态，head节点持有锁，锁被释放后后面的节点会代替之前的head成为新的head节点 release释放锁的过程，掉用release方法 12345678910111213141516171819202122232425262728public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125;private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; //清除取消状态的节点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; //唤醒后一个等待的线程 if (s != null) LockSupport.unpark(s.thread);&#125; 调用LockSupport.unpark后，唤醒后一个中断的线程，队列剔除之前的head，这样往复，释放锁后继续唤醒后面的线程。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次性搞清楚unicode的代码点和代码单元]]></title>
    <url>%2F2018%2F09%2F15%2F%E4%B8%80%E6%AC%A1%E6%80%A7%E6%90%9E%E6%B8%85%E6%A5%9Aunicode%E7%9A%84%E4%BB%A3%E7%A0%81%E7%82%B9%E5%92%8C%E4%BB%A3%E7%A0%81%E5%8D%95%E5%85%83%2F</url>
    <content type="text"><![CDATA[最近在处理字符过滤，重新研究了下字符、unicode和代码点的相关知识，首先要说一下编码的基本知识unicode unicode unicode是计算机科学领域里的一项业界标准，包括字符集、编码方案等。计算机采用八比特一个字节，一个字节最大整数是255，还要表示中文一个字也是不够的，至少需要两个字节，为了统一所有的文字编码，unicode为每种语言中的每个字符设定了统一并且唯一的二进制编码，通常用两个字节表示一个字符，所以unicode每个平面可以组合出65535种不同的字符，一共17个平面。 由于英文符号只需要用到低8位，所以其高8位永远是0，因此保存英文文本时会多浪费一倍的空间。 比如汉子“汉”的unicode,在java中输出 1System.out.println("\u5B57"); UTF-8unicode在计算机中如何存储呢，就是用unicode字符集转换格式，即我们常见的UTF-8、UTF-16等。 UTF-8就是以字节为单位对unicode进行编码，对不同范围的字符使用不同长度的编码。 Unicode Utf-8 000000-00007F 0xxxxxxx 000080-0007FF 110xxxxx 10xxxxxx 000800-00FFFF 1110xxxx 10xxxxxx 10xxxxxx 010000-10FFFF 11110xxx10xxxxxx10xxxxxx10xxxxxx Java中的String对象就是一个unicode编码的字符串。 java中想知道一个字符的unicode编码我们可以通过Integer.toHexString()方法 12345678910111213String str = "编";StringBuffer sb = new StringBuffer();char [] source_char = str.toCharArray();String unicode = null;for (int i=0;i&lt;source_char.length;i++) &#123; unicode = Integer.toHexString(source_char[i]); if (unicode.length() &lt;= 2) &#123; unicode = "00" + unicode; &#125; sb.append("\\u" + unicode);&#125;System.out.println(sb);输出\u7f16 对应的utf-8编码是什么呢? 7f16在0800-FFFF之间，所以要用3字节模板：1110xxxx 10xxxxxx 10xxxxxx。7f16写成二进制是：0111 1111 0001 0110按三字节模板分段方法分为0111 111100 010110，代替模板中的x，得到11100111 10111100 10010110，即“编”对应的utf-8的编码是e7 bc 96，占3个字节 codepointunicode的范围从000000 - 10FFFF，char的范围只能是在\u0000到\uffff，也就是标准的 2 字节形式通常称作 UCS-2，在Java中，char类型用UTF-16编码描述一个代码单元，但unicode大于0x10000的部分如何用char表示呢，比如一些emoji：😀 java的char类型占两个字节，想要表示😀这个表情就需要2个char，看如下代码 12345String testCode = "ab\uD83D\uDE03cd";int length = testCode.length();int count = testCode.codePointCount(0, testCode.length());//length=6//count=5 第三个和第四个字符合起来代表😀，是一个代码点,如果我们想取到每个代码点做一些判断可以这么写 12345678910111213 String testCode = "ab\uD83D\uDE03cd"; int cpCount = testCode.codePointCount(0, testCode.length()); for(int index = 0; index &lt; cpCount; ++index) &#123; //这里的i是字符的位置 int i = testCode.offsetByCodePoints(0, index); int codepoint = testCode.codePointAt(i); &#125;//输出i:0 index: 0 codePoint: 97i:1 index: 1 codePoint: 98i:2 index: 2 codePoint: 128515i:4 index: 3 codePoint: 99i:5 index: 4 codePoint: 100 也就是按照codePointindex取字符，0取到a，1取到b，2取到\uD83D\uDE03也就是😀，3取到c，4取到d；按照String的index取字符，0取到a，1取到b，2取到\uD83D，3取到\uDE03，4取到c，5取到d。这就是codePointIndex和char的index的区别。 取到codePoint就可以按照unicode值进行字符的过滤等操作。 如果有个需求是既可以按照unicode值过滤字符，也能按照正则表达式过滤字符，并且还有白名单，应该如何实现呢。 其实unicode过滤和正则表达式过滤并不冲突，自己实现自己的过滤就好了，如果需求加入了过滤白名单就会复杂一些，不能直接过滤，需要先检验是否是白名单的index。 我的思路是记录白名单char的index，正则表达式或其他过滤方式可以获得违规char的index，unicode黑名单的codepointIndex可以转换成char的index，在获取codePont的index时可以判断当前字符是单char字符还是双char字符，双char字符需要添加2个下标，方法如下 123456789//取到unicode值 int codepoint = testCode.codePointAt(i);//将unicode值转换成char数组char[] chars = Character.toChars(codepoint);charIndexs.add(pointIndex);if (chars.length &gt; 1) &#123; //表示不是单char字符，记录index时同时添加i+1 charIndexs.add(pointIndex + 1);&#125; //例 String str = “ab\uD83D\uDE03汉字”;想处理emoji，那记录的下标就是2、3，最后和白名单下标比较后统一删除 如何区别char是一对还是单个就之前的例子ab\uD83D\uDE03cd，换种写法\u0061\u0062\uD83D\uDE0\u0063\u0064程序是如何将\uD83D\uDE03解析成一个字符的呢。这就需要Surrogate这个概念，来自UTF-16。 UTF-16是16bit最多编码65536，那大于65536如何编码？Unicode 标准制定组想出的办法是，从这65536个编码里，拿出2048个，规定他们是「Surrogates」，让他们两个为一组，来代表编号大于65536的那些字符。编号为 U+D800 至 U+DBFF 的规定为「High Surrogates」，共1024个。编号为 U+DC00 至 U+DFFF 的规定为「Low Surrogates」，也是1024个。他们组合出现，就又可以多表示1048576中字符。 看一下String.codePointAt这个方法 12345678910static int codePointAtImpl(char[] a, int index, int limit) &#123; char c1 = a[index]; if (isHighSurrogate(c1) &amp;&amp; ++index &lt; limit) &#123; char c2 = a[index]; if (isLowSurrogate(c2)) &#123; return toCodePoint(c1, c2); &#125; &#125; return c1;&#125; 其中有两个方法isHighSurrogate、isLowSurrogate。第一个方法判断是否为高代理项代码单元，即在’\uD800’与’\uDBFF’之间，第二个方法判断是否为低代理项代码单元，即在’\uDC00’与’\uDFFF’之间。 codePointAtImpl方法判断当前char是高代理项代码单元，下一个是低代理项代码单元，则这两个char是一个codepoint。 再来看一下unicode转UTF-16的方法 如果U&lt;0x10000，U的UTF-16编码就是U对应的16位无符号整数（为书写简便，下文将16位无符号整数记作WORD）。如果U≥0x10000，我们先计算U’=U-0x10000，然后将U’写成二进制形式：yyyy yyyy yyxx xxxx xxxx，U的UTF-16编码（二进制）就是：110110yyyyyyyyyy 110111xxxxxxxxxx。 还是以U+1F603这个😃为例子，U’=U-0x10000=F603写成2进制就是1111011000000011，不足20位前面补0，变成0000111101-1000000011，替换y和x就是1101100000111101，1101111000000011，最后UTF-16编码就是[d83d，de03] 和上面一样。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[番茄工作法]]></title>
    <url>%2F2017%2F07%2F07%2F%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95%2F</url>
    <content type="text"><![CDATA[你是否经常会发现小事儿忙活了一天大事一样都没办，或者因为各种原因重要的事情一拖再拖，做一件事情没有专注力，经常分神。 你还没有做好时间管理，时间管理是个人管理中很重要的一环，很多人也尝试过一些时间管理的理论或工具，最终不是因为复杂而放弃，就是因为没有毅力坚持不下去。 除了番茄工作法，其他的时间管理理论我也有学习，比如GTD和柳比歇夫的时间记录法。 GTD系统很复杂，光书就有3本，偏向于对任务的整体把握，柳比歇夫的时间记录法没有强大的执行力根本不可能完成，番茄工作法更关注于执行和专注。 如果你一直苦恼学不会时间管理，或者没有合适的工具，那么试试番茄工作法吧，它简单到没有任何时间管理概念的人都可以很快上手，应该是目前最简单易行的时间管理方法了。 番茄工作法使用起来非常简单。也是一个很好的入门级时间管理工具，但它并不是适合所有人，如果你已经形成了自己的时间管理体系就可以忽略这篇文章了，时间管理是一个系统，适合你的才是最好的。 流程使用番茄工作法非常简单，只需要： 一支笔 一个计时器——可以是秒表、厨房闹钟或者找一个番茄钟的app 三个清单——分别是活动清单，今日待办和记录表 活动清单——就是收集表，列出所有需要做的事情。 今日待办——从活动清单中挑出几个今天要专注做的事情，不要贪多刚开始3件事就可以了。 记录表——对今天执行情况的一个记录与复盘，看看预估与执行的差距。 如果觉得纸质的麻烦，直接找个趁手的app，或者小程序。 清单系统是每个时间管理工具必备的，它最大的作用就是清空你的大脑。大脑主要是思考用的而不是记忆用的，有调查研究人的大脑同一时间最多只能关注7件事，用大脑去记录不仅耗费精力而且很有可能会忘记，我们的大脑每天都会闪现出很多想法，及时的记录单清单中清空你的大脑。 如何吃番茄从今日待办中挑出最重要，或者是马上要执行的一个任务。找出你的计时器，设置25分钟倒计时。在接下来的25分钟里全神灌注地完成这项工作。25分钟到停止工作，休息5分钟，做记录，再进行下一个番茄钟。执行完4个番茄钟，休息30分钟。 吃番茄的流程是非常简单的，不过还有几点原则需要了解。 番茄钟的时间可以调整，推荐是25分钟，刚开始无法做到25分钟可以适量减少，但不要小于10分钟。 一个番茄钟是不可分割的，如果中途被打断，如被别人叫走或自己中断，则这个番茄钟作废。 经过预估，如果一个任务需要七个以上的番茄钟就应当拆分它。 有人可能会说这不就是工作25分钟休息5分钟吗，我平时工作一天都不怎么休息。 如果你也这么想那还没有完全领悟番茄工作法，之前在讲流程时说的是全神贯注的25分钟，就是抵抗所有干扰专心只做这一件事，做到这点真的很难。 人的大脑每天都会迸发出各种想法，如果任由大脑想起什么就去做什么，你会发现最终一件事都没做好。 身处信息时代，手机、微信、淘宝、新闻无时不刻不吸引着你的注意力。 你肯定有这样的经历: 工作或学习时微信或qq响了，看看朋友圈或公众号又有什么新资讯，或者jd又做活动了，再刷刷淘宝，等回过神发现已经过去好久，刚刚工作到哪一步又忘了。 我之前的文章提过，人脑和cpu一样，频繁的切换任务会消耗大量的时间，人脑恢复之前的工作状态需要一个过程。 番茄钟里面的专注时间是不允许有这类事情发生的，否则这个番茄作废。 关于中断中断是不可避免的，要做的就是尽量保护你的番茄，中断分为内部中断和外部中断。 内部中断举例： 上个厕所 倒杯水喝 给xxx打个电话 刷刷手机，看看感兴趣的新闻或文章 内部中断是自己引起的，刚开始内部中断会非常多，像上厕所倒水这种事情就需要调整到休息的5分钟去做，其他脑子里蹦出的想法需要单独记录在计划外事务中，在执行完当前的番茄钟再去处理，并在当前任务后标注（`）。 处理内部打断的机理，就是逆转我们与打断的决定与被决定关系，让我们决定打断是否发生，而不是受制于打断。 外部中断-被他人打断 在工作环境中经常会被一些外部因素打断，例如： 同事请教你解决问题； 老板突然找你； 接电话； qq、微信、msn弹框； 外部中断都是和别人有关的，处理的原则和内部中断差不多，我们自己来决定是否要打断。 通讯软件关掉消息提示，或者在休息时统一查看，如果是同事过来找你，不是非常紧急的事情你可以礼貌的说明现在手头还有事，过一会再来找你或你去找他，打断一次在当前工作后记录（-）并把事项计入待办清单中。 如果是非常紧急的事情那不得不中断这个番茄钟了，比如老板叫你去办公室谈话吗，你不可能和老板说我再吃番茄吧。 不要觉得经常拒绝别人是很不礼貌的事情，这种推迟对想要和沟通的人来说是完全可以理解的，然而这种推迟可以极大的提高你的工作效率。 计划与回顾只是学会吃番茄还不够，最重要的阶段是每天的分析与计划阶段。 在计划每日待办时需要预估每项任务所花费的番茄数，然后记录实际吃掉的番茄数与打断次数，在每天的分析复盘阶段我们需要关注以下几点: 计划的任务是否已经完成，添加了哪些计划外任务。 任务的中断次数自己是否满意。有哪些中断是不受控的。 任务预计番茄数与实际番茄数对比差了多少，思考以后计划需要那些调整。 形成这样的反馈系统才会让你对时间的掌控越来越准。 通过比较，预估番茄数和实际完成用番茄树可以及时反馈修正自己的目标设定，使目标明确化，辨别并删除不必要的工作。 节奏番茄工作法工作25分钟休息5分钟能培养我们高效的工作节奏，不至于工作太久身体得不到休息，也让工作的25分钟专注提高产出。 时间长了，你会自觉的进入专注-休息-专注的节奏中，尽可能的排除干扰，同时一步一步的达成设定的目标减少焦虑感。 最后，番茄工作法也只是一个工具，适不适合你试过才知道。]]></content>
      <categories>
        <category>读书</category>
        <category>时间管理</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文章没有逻辑？]]></title>
    <url>%2F2017%2F05%2F23%2F%E5%86%99%E6%96%87%E7%AB%A0%E6%B2%A1%E6%9C%89%E9%80%BB%E8%BE%91%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[我们在生活或工作中可能遇到过这样的事情： 脑子里很多想法但写出来的文章没有逻辑与结 和别人表达一件事情总是说不清逻辑 看书或听分享自己很难归纳出重点 这些其实就是缺少结构思考的能力，什么事结构思考力呢？ 结构存在于每个整体与局部关系的无穷变化中，每个局部表现整体，而局部的意义又由整体来决定。 结构思考力是指以结构的视角从过个侧面全面而清晰、强调“先总后分”的分析事物的一种方法。 下面就分享一下看李忠秋的《结构思考力》的一些心得 什么是结构思考力结构思考力有四个基本点书中给了一个例子： 假如你是董事长，你的秘书早上给你打电话：“董事长您好！刘经理来电话说系统出现突发状况，4点钟他无法参加会议了，小张说他晚一点开会没关系，明天再开也可以，但最好别11点30分之前开。科室会意思明天已经被别人预定了，但星期五是空着的。王总的秘书说，王总明天需要很晚才能从外地出差回来。我建议把会议时间定在星期五的10点比较合适，您看行吗？” 这个表达非常乱，那怎么说才不乱呢？商务沟通中时间比较紧迫，所以一定是先说结果后说原因更有效率。原因可以被分类：人为原因会议室原因。原因可以总结概括。表达式按职务顺序排列。 参考答案： “我们可以将今天下午4点的会议改在星期五上午10点开吗？因为王总、刘经理和小张都可以参加，并且本周五会议室还能预定” 这样拆分后可以在最短时间内把问题表达清楚。如果你只有5秒钟，直接说结论；如果老板给你30秒，可以说到底二级；给你1分钟可以说到第三级。 这个案例可以得出结构思考力的四个基本特征，也是金字塔原理的四个基本原则： 结论先行 以上统下 归类分组 逻辑递进 先说结论在现在的高效社会可以极大的提高沟通效率，最近工作中负责带新人，他经常会有自己解决不了的代码问题来问我，我发现他的沟通方式就有问题。 他会先描述问题的操作顺序，我先怎么着，然后怎么着，还要等到我的答复再继续，描述情景就花了很长时间，然而我依旧不知道他想问的究竟是什么，有时候在他问的过程中我会揣测他的问题，最后他问的是别的问题… 他的问题就是没有按照结构化表述，问问题前没有自己想清楚，想到哪就说到哪，逻辑混乱，前面的描述可能和他问的问题没有什么关系。 后来我给他提的一个要求就是先说你的问题再说过程和情景，这样我能准确的定位他遇到的问题，就算他在描述是说到不相关的我也能很快把他拽回来，节省了很多沟通的成本。 如果工作中你在汇报工作时遇到了一个不耐烦的老板，思考一下是不是你没有结论先行，结构化的表达，当然每个老板的脾气也不一样。 我们如何接收信息如今我们处在信息爆炸的时代，每天都有很多新闻、文章、分享、微课进入我们的视角，每天都用很多的时间刷微信，生怕错过了有用的信息。 关注了大量的公众号，看的时候都觉得不错，讲的有道理，很多人估计就是照单全收，尤其是泛滥在朋友圈中的毒鸡汤，所以独立思考的能力很重要。 我们如何判断文章是否正确或是否对自己有用呢？ 我们要分析这件事是不是对我很重要，正确的道理很多，但对我们不一定有用，时间是有限的，我们看对自己有帮助或可以提高的信息。 思考作者是通过什么得出这个结论，是通过一件事还是别人的转述，我们能否得出同样的结论。 作者得出结论的环境是否有很强的适用性，简单说这件事和你的现在和将来有没有关系。 最后结合你自己的情况，如果碰到了这样的问题你有什么看法。 通过简单的几个问题就能过滤大量你用不到的信息。 如何构建金字塔金字塔结构分为纵向和横向两个方向 构建纵向结构书中给了两种方法： 自上而下，适用于主题比较明确的情景，比如写文章、做汇报、演讲。 自上而下是用疑问回答做分解。 设想问题的时候一定要从对方的角度考虑问题，而不是仅仅表达自己想到的，比如你在请教别人问题的时候或者分享经验时一定要尽量想别人会怎么问你，这样你的准备会更加充分。 你想想如果别人问你时你说这个我还没想过，这个我还不明白，场面有多尴尬。 自下而上，适用于只有底层杂乱的资料或信息的情景。 如根据一年的工作内容做工作汇报；老板给你一堆材料写ppt；学习看书或听讲座时快速整理杂乱的信息； 流程分为3个步骤： 1、收集信息2、分类3、概括总结 实际的情景中不太可能只用一种方法就把结构建完，一定是两种方法同时使用。 就比如写文章，你会先定关于这个文章的几个观点，然后搜集材料，如果没有最下面的素材，你无法支撑你的观点，你也需要判断搜集的素材是否符合你的观点，向上概括总结时你的观点需不需要调整，所以自上而下，自下而上需要同时使用，相互配合。 结构化套路在分析问题过解决问题时厉害的人总是能抓住重点，全面的分析问题，其实是他们想我了很多结构化套路。 而这些套路就成了他们的快捷方式，在碰到对应的问题时能快速反应。 最常用的大家都知道的就是2w1h模型——黄金思维圈 w-what 是什么（现象）w-why 为什么 （原因）h-how 怎么做 （解决方案） 这个模型非常常见，这符合大部分人的思维习惯。 你可以随便找几个公众号的文章拆解一下，你会发现很多文章的结构使用了2w1h， 先引出想要表达的观点。再分析发生这件事的原因。最后通过自己的经验告诉大家应该如何做。 我们看文章写笔记时也能使用黄金思维圈将文章拆解，快去提出干货。 这是一篇公众号文章的评论： What：买书提升自己的方式到底是什么？学习的目的是更新操作系统，把买来的都学完是典型的定价错误。Why：由于缺乏一些必备知识导致认知失调，用不合适的经验去解释世界、解决问题，形成错误的认知。How：①必须构建自己的操作系统，操作系统即世界观、人生观和价值观对应的概念、原则、假设、模型、推演逻辑。②理解高效学习方法：基于目标导向、架构导向、表征导向、高效导向、输出导向的学习方法③建议直接把得到APP中的付费全买了④想办法把你的投入赚回来⑤适用边界是高品质课程和书。 原文链接 简单方法彻底解决囤课、囤书不看的焦虑症 这种总结和输出能增加你和信息的连接度。 相信你看过的很多文章都不记得说过什么了，如果你看到的好文章都能输出心得，并且总结回顾，短暂记忆就会变成长久记忆，变成你的知识。 这种思考方式也出现在生活的各个角落，而我们很多时候思考问题仅仅还是停留在what 阶段。 比如领导给你安排工作，有时指出的是具体的一件事要怎么做，如果你仅仅是按照领导的安排去做，你在领导那仅仅是一个合格的员工而已。 假如你分析了领导安排工作的原因，他要达到的目的，你就不仅仅局限于领导的解决方法，而是思考这个是不是最优解，自己有没有别的方案。 spenser说过：也就是说，你让老板做选择题，而不是让他做填空题。如果你能考虑到老板都没考虑到的，老板爱死你了。 还有很多模型，比如GROW模型，目标制定的SMART，战略分析的SWOT模型，有兴趣的朋友可以去看看。 结构思考力不是看一本书就能学会，需要大量的联系，书中作者给了大量的事例，想深入了解的看看原著吧。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[没有人能伤害你,除非你愿意]]></title>
    <url>%2F2017%2F04%2F26%2F%E6%B2%A1%E6%9C%89%E4%BA%BA%E8%83%BD%E4%BC%A4%E5%AE%B3%E4%BD%A0%EF%BC%8C%E9%99%A4%E9%9D%9E%E4%BD%A0%E6%84%BF%E6%84%8F%2F</url>
    <content type="text"><![CDATA[前一段时间有次出门倒垃圾，恰好听见隔壁一个妈妈生气的在骂自己的儿子，说话很难听，大概原因就是最近孩子都没考好，而这位妈妈的表现已经不是在教育，而是发泄自己的情绪，孩子一句话没有回，不知道是因为害怕还是已经习惯。 发脾气对事情没有任何好处，孩子或多或少很产生心里阴影，而这位母亲不知道会不会在情绪稳定后又后悔自己的行为。 我们每天都会因为各种事情产生不同的情绪，而如何处理这些情绪需要很大的智慧，情绪管理是个人修炼中很重要的一环，很多人在遇到事情后根本控制不住自己的情绪，负面情绪经常出现且持续不断，影响身心健康，人际关系和日常生活。下面分享一下自己在情感修炼上的一些感悟。 情绪不分好坏我们都知道人应该尽量保持积极的情绪，尽量减少消极的情绪，其实情绪并不分好坏，情绪引起的行为才有好坏之分。 一个不会生气的人只能受别人的欺负，而一个动不动就生气的人将被被情绪控制。适度的焦虑会让我们更加努力，然而焦虑过度则会使人变得消极，甚至变得抑郁。 处理不好负面情绪会给身心产生巨大的伤害，人们常说“性格决定命运“，有些性格和癌症的发生有很大关系，有统计资料显示，与普通人相比，性格忧郁、感情不外露的人患癌症的比例比性格开朗的人要高出15倍，尤其好发于受了一些挫折后长期处于精神压抑、焦虑、悲伤等负面情绪的人。 有研究表明，生气会使人体肝脏存储的气血急剧的流失，流失很容易，在储存就很难了，过度生气会导致肝气郁结，情绪更加难以控制，行程恶性循环。 我们都碰到过脾气很大的人，他们在情绪上在个性上是强烈的，他们经常因为一点小事而暴跳如雷，他们总是把自己的意愿强加在别人身上，一旦不按他们的想法发展他们就发脾气。 表面上看上去他们是强的那一方，别人都要让着他，事实真的是这样吗? 每个人都有自己的情绪开关， 碰到了特定的事情就会有失去理智，爱发脾气的人把自己的情绪开关拱手让给别人，别人的一举一动随时都可能触发他们的开关，控制他们情绪的是外在的人和事，而不是他自己，他们成了情绪的奴隶。 为什么他们要表现的这么强，因为他们“小”的很，当一个人表现的很用力时，说明自己的内心已经不够了，你如果足够“大”，对自己足够有信心，你不用大声的叫，你只要轻声的说就可以了。你能强多久呢，你一直绷得很紧，到最后就崩溃了。 真正厉害的人都是柔软的真正心智成熟的人不是没有情绪，他们只不过不会被情绪左右罢了，一颗柔软的心才能有真正强大的内在力量。 1863年南北战争，南方将军罗伯特·李向南撤退，途中遭遇暴雨，一条河横在他们前头，河水暴涨，他们无法渡河，而乘胜追击的北方军就在后面，北方军只要在前进一步，就可以俘获李将军并结束这场战斗，林肯要求米德将军立即袭击李将军，命令他事先不要召集军事会议以免贻误战机。可米德将军硬是先召开了军事会议，犹豫官网，最后河水退去后丽江就和他的军队就这样逃走了。 林肯对这件事震怒至极，在那个时机任何一位将军都可以击败李将军，林肯给迷德写了一封信，最然措辞谨慎，但在当时已经是极为尖锐的指责了。 最后，米德根本没有收到这封信，在林肯死后才从一大堆文件中找到，林肯知道，批评和指责并没有任何效果。 情绪ABC美国心理学家阿尔伯特·艾利斯有一个著名的情绪ABC理论：A（activating event）是指具体的事件，B(belief）是一个人对A的看法、评价和解释，C(consequence）是指这个人产生的情绪及行为结果。 人们通常认为诱发事件A导致了结果C，什么事就应该有什么情绪反应，所以大多数人都是针对A解决问题。 像之前的例子，孩子没考好让妈妈生气，大多数家长估计就是批评教育孩子，给他报补习班，自己盯着孩子学，想尽一切办法搞定A，然而他们没有思考过自己的这个想法是不是一定是对的，孩子没考好是不是自己的教育出了问题，是不是偶然现象，考不好是否自己就要生气。 杨绛先生说过：没有人能伤害你,除非你愿意。 真正伤害你的，往往不是事情本身，而是你对事情的看法，所以我们是有选择权的，只不过很多人把它交给了别人。 你的质量决定了你的情绪物理学上我们知道，一个物体质量越大，它受到撞击后自身的改变越小，人其实也一样，质量小的人发生很小的事情会有很大的反应，质量大的人正好相反，有些事很多人都受不了，但有些人能够坦然面对。 你越“重”，你的情绪越稳定，当我们的心量不够大，没有足够的力量面对时，就会变成对当下事情的抗拒，认为事情不应该发生，我们必然会找一个替罪羊去承担这个错误，这可能是你的爸妈，你的伴侣，你的孩子。 内心越不稳定，就期待环境稳定，一旦事情稍稍偏离自己的期待，负面情绪就会爆发。 小到周围的噪音，孩子的哭闹，地铁上的拥挤，大到失业离婚，股票暴跌。 然而抱怨和批判不能解决任何问题，反而让你的心量更低，人生不如意之事十之八九，如果期待一切都如你的意，你一辈子也不会如意。 情感的修炼是一个漫长的过程，控制好情绪才能控制好人生。]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>脾气</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud Fegin超时重试源码]]></title>
    <url>%2F2017%2F04%2F10%2FSpringCloud-Fegin%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[springCloud中最重要的就是微服务之间的调用，因为网络延迟或者调用超时会直接导致程序异常，因此超时的配置及处理就至关重要。 在开发过程中被调用的微服务打断点发现会又多次重试的情况，测试环境有的请求响应时间过长也会出现多次请求，网上查询了配置试了一下无果，决定自己看看源码。本人使用的SpringCloud版本是Camden.SR3。 微服务间调用其实走的是http请求，debug了一下默认的ReadTimeout时间为5s，ConnectTimeout时间为2s，我使用的是Fegin进行微服务间调用，底层用的还是Ribbon，网上提到的配置如下 12345ribbon: ReadTimeout: 60000 ConnectTimeout: 60000 MaxAutoRetries: 0 MaxAutoRetriesNextServer: 1 超时时间是有效的但是重试的次数无效，如果直接使用ribbon应该是有效的。 下面开始测试：在微服务B中建立测试方法，sleep 8s 确保请求超时 123456789@PostMapping("/testa") public Integer testee()&#123; try &#123; Thread.sleep(8000L); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return 9; &#125; 在微服务A中使用fegin调用此方法时看到有异常 看到在SynchronousMethodHandler中请求的方法 1234567891011121314151617Object executeAndDecode(RequestTemplate template) throws Throwable &#123; Request request = targetRequest(template); if (logLevel != Logger.Level.NONE) &#123; logger.logRequest(metadata.configKey(), logLevel, request); &#125; Response response; long start = System.nanoTime(); try &#123; response = client.execute(request, options); response.toBuilder().request(request).build(); &#125; catch (IOException e) &#123; if (logLevel != Logger.Level.NONE) &#123; logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start)); &#125; //出现异常后抛出RetryableException throw errorExecuting(request, e); &#125; 出现异常后调用 throw errorExecuting(request, e) 抛出异常 在调用executeAndDecode的地方catch 1234567891011121314151617@Override public Object invoke(Object[] argv) throws Throwable &#123; RequestTemplate template = buildTemplateFromArgs.create(argv); Retryer retryer = this.retryer.clone(); while (true) &#123; try &#123; return executeAndDecode(template); &#125; catch (RetryableException e) &#123; //重试的地方 retryer.continueOrPropagate(e); if (logLevel != Logger.Level.NONE) &#123; logger.logRetry(metadata.configKey(), logLevel); &#125; continue; &#125; &#125; &#125; retryer.continueOrPropagate(e); 这句就是关键继续跟进 123456public void continueOrPropagate(RetryableException e) &#123; //maxAttempts是构造方法传进来的大于重试次数抛出异常,否则继续循环执行请求 if (attempt++ &gt;= maxAttempts) &#123; throw e; &#125; .... 默认的Retryer构造器 123public Default() &#123; this(100, SECONDS.toMillis(1), 5); &#125; 第一个参数period是请求重试的间隔算法参数，第二个参数maxPeriod 是请求间隔最大时间，第三个参数是重试的次数。算法如下： 1234long nextMaxInterval() &#123; long interval = (long) (period * Math.pow(1.5, attempt - 1)); return interval &gt; maxPeriod ? maxPeriod : interval; &#125; 我们能否改写参数呢？我们再看看SpringCloud的文档中关于Retry的配置 新建一个配置类 12345678@Configurationpublic class FeginConfig &#123; @Bean public Retryer feginRetryer()&#123; Retryer retryer = new Retryer.Default(100, SECONDS.toMillis(10), 3); return retryer; &#125;&#125; 在feginClient是加入configuration的配置 12@FeignClient(value = "fund-server",fallback = FundClientHystrix.class,configuration = FeginConfig.class)public interface FundClient 重启重试，只调用了一次，Fegin重试次数解决。我们再看看请求超时这里的参数 123456789101112131415161718192021@Override public Response execute(Request request, Request.Options options) throws IOException &#123; try &#123; URI asUri = URI.create(request.url()); String clientName = asUri.getHost(); URI uriWithoutHost = cleanUrl(request.url(), clientName); FeignLoadBalancer.RibbonRequest ribbonRequest = new FeignLoadBalancer.RibbonRequest( this.delegate, request, uriWithoutHost); //请求参数 IClientConfig requestConfig = getClientConfig(options, clientName); return lbClient(clientName).executeWithLoadBalancer(ribbonRequest, requestConfig).toResponse(); &#125; catch (ClientException e) &#123; IOException io = findIOException(e); if (io != null) &#123; throw io; &#125; throw new RuntimeException(e); &#125; &#125; 其中ReadTimeout 和 ConnectTimeout 读取的就是ribbon的配置，再来看一眼 12345ribbon: ReadTimeout: 60000 ConnectTimeout: 60000 MaxAutoRetries: 0 MaxAutoRetriesNextServer: 1 如果想覆盖ribbon的超时设置可以在刚刚写的FeginConfig里注入下面的bean 12345@Beanpublic Request.Options feginOption()&#123; Request.Options option = new Request.Options(7000,7000); return option;&#125; 总结：使用开源的东西在弄不清问题出在哪时最好能看看源码，对原理的实现以及自己的编码思路都有很大的提升。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界在加速，你还在原地踏步]]></title>
    <url>%2F2017%2F03%2F21%2F%E4%B8%96%E7%95%8C%E5%9C%A8%E5%8A%A0%E9%80%9F%EF%BC%8C%E4%BD%A0%E8%BF%98%E5%9C%A8%E5%8E%9F%E5%9C%B0%E8%B8%8F%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[从AlphaGo战胜李世石到年前 AlphaGo2.0在快棋平台59连胜血洗围棋界，人们感叹人工智能已经攻克了人类最后的智慧堡垒。 人工智能离我们有多远先说一个大家可能听过的概念：吓尿指数 一个人去到未来，他被环境吓尿了，这个时间差就是“吓尿指数”。 举个例子：你现在邀请200年前的人来现在玩，顺便看看他对“未来“的感受，他可能无法理解现在的社会甚至被吓尿，但是他回去后想把别人吓尿，再往前200年是不够的，可能要回到更古老的过去，比如第一次工业革命之前，那时候还没有文明，还是狩猎采集的时代。狩猎时代的人想再把前人吓尿，往前1万多年是不够的，可能需要10万年前或者更久，用火或语言把别人吓尿，而我们去往20-30年后的未来估计也会被吓尿。 吓尿单位是呈指数级缩短，这源于加速回报定律，和滚雪球类似。21世纪的15年发展相当于20世纪一个世纪的速度。技术的发展可能远超了我们的想象。 人工智能离我们还远吗，我列举几个已经发生的例子： 1|机械制造富士康因面临短期缺工，人力成本增加，已经在用机器人逐步替代人，美国一家公司研发的搬运机器人适应能力很强，可以抓取各种形状的货物，对搬运工人是一个挑战。 机器人在制造业中更广泛地应用是大势所趋，机器人不用休息，不会跳楼也不会罢工，在流水线生产、仓库装卸、农场采摘、驾驶、打扫等领域机器将进一步巩固其地位。 你可能会说，这些机器也只能替代比较低级的简单重复劳动，那你可能没有看过下面的例子: 2|法律美国一家公司研发的ROSS人工智能律师可以理解自然语言、回答问题、提出假设并持续关注当前的法律动态。ROSS基于大数据+机器学习的模式对用户的提问进行反馈，随着越来越多的人使用ROSS，ROSS的能力和准确度将会呈现指数型的增长。ROSS已经为几十万破产企业提供服务，美国的破产律师日子也不好过。 3|医疗领域根据美国PDA药物评价和研究中心提供的数据，在美国每天至少有一例由于投药差错而造成的死亡，每年由于投药错误造成约130人受到损伤，自动配药机器人极大减少配药的错误率，避免人为影响，保证了配药环境的洁净标准，配药师将逐步被淘汰。 斯坦福大学一个联合研究团队开发出了一个诊断皮肤癌的人工智能，准确度达到了91%。 谷歌大脑与Verily公司联合开发了一款能用来诊断乳腺癌的人工智能，准确率已经超越了资深病理学家。 中国很多患者心中看病要找“老大夫”，因为他们经验丰富，但人学习的再快也比不过计算机，全球每天能产生亿万级的数据供人工智能学习。计算机在诊断和手术领域相比人类有几个优势： 有大数据的支撑它们“失误”的可能性极低 它们的稳定性极高，外科医生的医术再高超手也会抖。 4|金融领域从程序上看，股市其实比围棋更简单，目前已经有对冲基金公司将股票完全交给人工智能，通过深度学习、进化算法，人工智能可以通过自己的系统虚拟一批交易员，通过自己和自己竞争进化出最“优秀”的交易员，他们的投资回报率已经超过散户和普通的交易员。 研究得出结论说，在未来 10~20年，美国 47%的就业人口可能会面临失业风险，在中国这个数据可能大于60%，即便是想律师、金融分析师、保险理财师、医生、记着等看起来比较高端的职业也会受到很大的冲击。 这个时代已经没有“稳定“的工作了。最近已经感到越来越多的人开始焦虑，是什么导致的焦虑呢，是现在社会环境的变化的不稳定性，是突然觉得自己前几十年基本算白活了，是生怕自己跑的不够快被这个时代所淘汰，是看到了越来越多厉害的人还再成几何速度的成长。 我们该怎么办学会学习的能力学习已经成了我们这代人一辈子的事，很可惜中国的应试教育让很多人考完大学后对学习这件事情再也没有了兴趣。 这个世界唯一不变的就是变化，而且会越来越快，现在已经不是像父辈一个工作能做几十年的时代了。 也不是靠点小聪明，接触到好的机会就能成功的时代，现在能创业成功的都是真有本事的人。 能够快速的学习一样新技能或者新知识的能力很重要，而最关键的是保持对这个世界保持敏感度和好奇心。 迈出第一步很困难，但只要你跨出了第一步，你会发现这个世界原来这么精彩，你对知识的渴望和焦虑会让你根本停不下脚步。 对自己的职业生涯要做长久打算现在依然有很多人削尖了脑袋想当公务员，想进入体制内，想得到一份“稳定”的工作给自己安全感，但其实真正的安全感永远来自自己的本事，自己的成长。 你是否有能力离开体制依然养活自己？ 你的行业是朝阳产业还是已经在走下坡路，大的就业环境将很大程度决定你的发展。 多去分析一下你所在的行业受大数据和人工智能的影响将会如何改变。 成为一个全才还是一个专才估计很多人会想到这样一种人，经常换职业，什么都尝试过，但是什么都不精。 我们都知道水桶能装多少水取决于最短的板，但这个原理只适用于考试，考试不会看你哪科考得最高，而是看你成绩之和，而社会不同，它只看你的长板是否够长。 那我们是不是要在某个领域或者一项技能上死磕呢？ 我们都听过一万小时理论，要想成为一个领域的专家，你需要坚持一万小时的刻意练习，这是一个好策略，但在时代快速变化的现在并不是最高效的。 在单一维度竞争是非常残酷的，简单说超过所有人和超过大部分的普通人所需要的付出努力差距会非常大，做到顶尖的永远是少数，奥运会人们也只会记住金牌，而且在人工智能快速发展的今天，你终其一生死磕出来的技能很可能在将来被替代，到时候你找谁说理去。 我认为最好的策略是：首先至少要在一个领域做的比普通人强，刻意练习的方法是必须的，然后再拓展其他领域或者维度的技能，不一定要深耕，二八定理同样适用，你可以花少量的时间去了解一个行业的大概，等各方面都有一定的能力后你将会有不同的视角，碰撞出自己独特的竞争力。 现在明星也流行跨界，又演戏、又唱歌、又主持、又去玩喜剧就是这个道理。 按现在流行的话讲：成为一个“斜杠青年”。 抱怨和抵抗是没用的的，我们要学会顺应潮流英国工业革命的时候工人们害怕丢掉工作到工厂砸机器，但是丝毫不会影响工业化进程。 我们现在已经进入了以大数据和人工智能为主导的第四次工业革命，各行各业会有很大的变革，而这造成很多人丢掉工作的同时也带来了新的机会。 特斯拉的汽车装配厂全部由机器人装配，汽车工会的人在特斯拉门口示威，抗议特斯拉不招汽车工会的工人，其实特斯拉的员工数量增长的非常快，只不过都是IT人员。 我们要学会顺应时代潮流的变化，努力改变自己去迎合时代，不改变只能被淘汰。 在智能时代最重要的能力就是和机器共事的能力，也就是用机器去完成我们很困难或者根本无法完成的工作。 如果你是工厂流水线的操作工，你可以学习如何操作流水线上的机器，就算再智能，机器也需要人的操作和维护。 如果你不想让你的孩子吃亏，趁早让他学习一门编程语言，因为在以后的时代，编程语言可能会像现在的英语一样重要。 那些简单的重复劳动被替代的概率很大，艺术、设计、创造或与人相关的工作被替换的概率很低。 这个时代正在加速，如果你还没有察觉到，它将和你擦身而过。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新晋程序员如何快速提升自己]]></title>
    <url>%2F2017%2F02%2F24%2F%E6%96%B0%E6%99%8B%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E6%8F%90%E5%8D%87%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[做javaweb已经有一段时间，虽然算不上大牛，但也积累了一些经验，最近主导公司一个项目的架构。同时指导新人，发现了新人身上存在的一些问题。我其实还算有耐心。但他们有些问题让我很抓狂。想起我刚工作时师傅抓狂的表情，我觉得有必要给刚毕业和刚入职场的程序员一些建议。 学习的态度和方法很重要刚工作不久肯定很多东西都不会，学校学的和真实的项目差很多，培训机构也只能教你一些表面功夫，你会经历各种异常和报错，不要恐慌，利用百度和谷歌，尽快和他们混个脸熟。 学会js的debug、ajax请求、表单提交、传参、json解析等基本知识，将数据的传递搞清楚，程序异常了先自己找找原因，debug试试，是js错误还是前段值没传过来，是后端变量名字没对上还是配置档配错了，仔细检查检查，不要一报错就找人解决，尽量自己找出解决方法，如果实在解决不了再去找同事帮忙，最好连同几个问题一起去问，别人也有工作要忙，经常打断会降低工作效率，影响别人的进度。 问问题前想好自己的问题再说，你可能会问，问问题都不会吗，是的，很多人不太注意自己沟通表达的方式。 我带的一个新人，每次问问题都是一堆语气词，你看，怎么怎么着，等着我回复，然后怎么怎么着，又等着我回复，说了一堆和问题不太相关的话，最后我实在忍不住，打断他说你到底想问什么，他才说出自己的问题。 问问题前在自己脑子里过一边，简洁的提出问题，再描述现象 有时别人给出一个具体方案没有解释清楚，我们也懂为什么时，在时间和条件允许的情况下去请教清楚：我刚开始工作领导是不让用system.out.println来输出的，一定要用logger，我就不明白为什么，之前教的就这么用啊，但是改起来也不费劲，我也没详细去问，直到后来接的一个项目，里面有很多system.out.println输出，你在控制台只能看到输出根本找不到是哪个类哪个方法输出的，我才明白为什么。 ###学习学习再学习 练习练习再练习想要成为一个顶尖高手，关键是刻意练习，成为一个优秀的程序员，不停地学习和练习是必须的。 新人刚开始时迷茫是很正常，想要努力学习却没有方向。多去问问前辈和同事还有领导，和他们沟通学习的方向，记住成长比成功更重要。 软件技术更新速度飞快，非关系型数据库、nodejs、容器技术、h5 、前后端分离、到现在react ironic 一套搞定ios android 微信公众号，你可能刚学会一个新技术又出来一个更稳定更好用的，所以自学能力非常重要，要时刻保持对新技术的敏感，不一定要精通，也不要出了什么都去学，一般新技术的产生都是为了解决现有技术的瓶颈，了解它产生的背景，以及要解决的问题很重要。 我们刚工作碰到的肯定是别人已经搭好框架的项目，我们写代码只是填充其血肉，我们很少思考他为什么这么写，这些配置都有什么用，换成别的行不行，有了一定基础后要试着尝试自己从0搭建一个项目，这样你就能明白这些过滤器、拦截器、插件、依赖的作用，对你的能力有很大的提升。 如果碰上一个刚起步的新项目会是一个很好的机会，你会经历整个架构的演变，碰到很多坑和问题，这些都是很宝贵的经验。 有了一些小想法或者新技术自己写个小项目试试，慢慢的你的经验会越来越丰富，而不是仅仅知道公司的项目，下班少去看电视剧，玩游戏，自己多实践，写写东西，等一个问题顺利解决或实现了一个小功能，你会体会到无比的成就感。 ###不要依赖技术大牛很长一段时间，我在碰到自己解决不了的问题时，都回去问公司里的大牛，感觉很可靠也很厉害，所有的问题都能解决，虽然问题是很快的解决了，但是很少有自己的思考，说白了就是懒，能靠着着别人。后来离开了这个大牛，遇到了问题只能自己死磕，就是一段时间的死磕是自己学到了很多知识，看懂了很多比较底层的原理，也变成了帮别人解决问题的人，提升很大。 ###养成看源码的习惯刚开始的时候我也很惧怕看源码，一个是懒，再就是觉得自己看不懂，后来没办法，代码出问题找不到原因，只能硬着头皮跟进去看，开始的确很费劲，看多了就能了解个大概了，你可以了解到一些技术细节，系统的看源码可以学习别人的编程思想，这里推荐学java的同学有时间去研究一下spring的源码，帮助多多。 ###代码规范代码规范很重要，不要以为代码是给机器读的就写的很随意，代码是给人看的，你不可能在这干一辈子，总有一天有人要接过你的代码，如果你的代码只有你能看懂，你能想到和你交接的人的心情吗，肯定很想从新写一遍，规范其实也不用非常严格，规范不是限制，下面给出一些常见的java规范： 除了静态变量，大部分标识符使用驼峰法则，标识符能准确的表达出它所代表的意义，不要使用supplier1、 service2、aaa、bbb等，包名小写，类名首字母大写，其他文件首字母都小写。 状态、类型、参数名称不要直接使用字符串或数字等比较，除非只有一个类中使用 这么写别人根本不知道2是什么状态 1234567891011121314if(orderStatus.equels(2)&#123; xxxx &#125; // 正确的写法 public interface OrderStatus&#123; public static final int ORDERSTATUS_NEW = 1;//新建 public static final int ORDERSTATUS_PAID = 2;//已支付 public static final int ORDERSTATUS_DELIVERY = 3;//已发货 if(orderStatus.equels(OrderStatus.ORDERSTATUS_PAID)&#123; xxxx &#125; ` 注释掉的测试代码或不用的类请尽快删掉，如果还有用的请添加FIXME+注释，否则时间长了自己也不知道为什么注释掉，代码越来越多不好维护 编译工具的format要统一，在formatter代码时最好不要全选整个类，而是只format编辑的方法，这样如果大家同时修改一个类而formatter不同会导致更新代码时大量的冲突 单个方法不要超过300行,类不要超过3000行，重构请参考《重构-改善既有代码的设计》 尽量缩小变量的作用域，作用域过大可能回引起很多想不到的bug。 如果代码需要公用，尽量不要复制粘贴，请提到service或util中。 做程序员对很多人其实很苦，你是否因为有“钱景“加入这个行业，你是否真的有兴趣长时间对着电脑敲代码，你能否因为一个小问题一晚上找不到原因继续坚持，如果你想好了就脚踏实地的努力，我们一起共同学习。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashmap 原理解析]]></title>
    <url>%2F2015%2F07%2F21%2Fhashmap-%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[HashMap的原理在面试时经常问到，也有很多人分析过，自己也写一写，仅供参考，部分内容参考别人的文章 HashMap的数据结构数组和链表是最基本的数据结构，但这两个基本是两个极端 数组数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找 时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难； 链表链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大 O(N)。链表的特点是：寻址困难，插入和删除容易。 Hashmap实际上是一个数组和链表的结合体 hashmap中存数据的过程，通过key得到hashcode，利用hashcode可以得到在数组中的下标，如果下标已经有东西了，就插入到链表的表头。取的话，通过key得到hashcode，确定下标，如果不止一个元素，就通过equals遍历链表取得。 hashmap大小是2的幂次方，是因为这样可以尽可能的减小碰撞的发生，碰撞越多，性能越差。 hashmap中有个loadFactor参数，为0.75，这个值用来决定什么时候要resize hashmap（目的是减少碰撞的发生，但是这件事情很耗时间） HashMap部分源码Entry 键值对HashMa加载因子 默认0.75若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.链表长度会越来越长,查找效率降低。反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.表中的数据将过于稀疏理Hash冲突的，形成链表 关键属性加载因子 默认0.75 若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.链表长度会越来越长,查找效率降低。 反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了.表中的数据将过于稀疏 hash算法hashCode的算法就不讲解了，在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，方法就是取模运算，这样元素的分布比较均匀，java中是这么做的 1234567/** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return h &amp; (length-1); &#125; 为什么数组的大小要是2的n次方大小，这样HashMap的性能最高。当length=2^n时，hashcode &amp; (length-1) ==hashcode % length，位运算当然比取余效率高。length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性 而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间。 在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的 1234567891011121314151617181920212223242526272829/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1; &lt;span style="color:#ff6666;"&gt; &lt;/span&gt;&lt;span style="color:#3366ff;"&gt;while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; threshold = (int)(capacity * loadFactor); table = new Entry[capacity]; init(); &#125; put方法1234567891011121314151617181920212223242526272829303132333435public V put(K key, V value) &#123; if (key == null) return putForNullKey(value); int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(hash, key, value, i); return null; &#125;//第2和3行的作用就是处理key值为null的情况，我们看看putForNullKey(value)方法private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null; &#125; 如果有null的元素侧替换掉 如果key为null的话，hash值为0，对象存储在数组中索引为0的位置。即table[0] get方法12345678910111213public V get(Object key) &#123; if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null; &#125; resize方法在addEntry方法中判断如果map的大小超过阈值则进行扩容 void addEntry(int hash, K key, V value, int bucketIndex) { Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); if (size++ &gt;= threshold) resize(2 * table.length); } void resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); } //调用了比较消耗性能的transfer方法 void transfer(Entry[] newTable) { Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) { Entry&lt;K,V&gt; e = src[j]; if (e != null) { src[j] = null; do { Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } while (e != null); } } } transfer方法，将HashMap的全部元素添加到新的HashMap中,并重新计算元素在新的数组中的索引位置，在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize，默认的情况下，数组大小16，当元素个数超过16*0.75=12时，就把数组扩展一倍32，重新计算每个元素在数组中的位置，数组的复制非常消耗性能，所以如果预知map的大小，那么初始元素个数能够提高map的性能。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java编程中“为了性能”尽量要做到的一些地方]]></title>
    <url>%2F2014%2F03%2F05%2FJava%E7%BC%96%E7%A8%8B%E4%B8%AD%E2%80%9C%E4%B8%BA%E4%BA%86%E6%80%A7%E8%83%BD%E2%80%9D%E5%B0%BD%E9%87%8F%E8%A6%81%E5%81%9A%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%B0%E6%96%B9%2F</url>
    <content type="text"><![CDATA[最近的机器内存又爆满了，除了新增机器内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。 下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。 尽量在合适的场合使用单例使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面： 第一，控制资源的使用，通过线程同步来控制资源的并发访问； 第二，控制实例的产生，以达到节约资源的目的； 第三，控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。 尽量避免随意使用静态变量要知道，当某个对象被定义为stataic变量所引用，那么gc通常是不会回收这个对象所占有的内存，如 123public class A&#123; static B b = new B(); &#125; 此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。 尽量避免过多过常的创建Java对象尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。 尽量使用final修饰符带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。另外，如果一个类是final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。 尽量使用局部变量调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。 尽量处理好包装类型和基本类型两者的使用场所虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。 慎用synchronized，尽量减小synchronize的方法都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。 尽量使用StringBuilder和StringBuffer进行字符串连接这个就不多讲了。 尽量不要使用finalize方法实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。 尽量使用基本数据类型代替对象String str = “hello”;上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；String str = new String(“hello”);此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o 单线程应尽量使用HashMap、ArrayListHashTable、Vector等使用了同步机制，降低了性能。 尽量合理的创建HashMap当你要创建一个比较大的hashMap时，充分利用另一个构造函数public HashMap(int initialCapacity, float loadFactor)避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。 尽量在finally块中释放资源程序中使用到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。 尽量使用移位来代替’a/b’的操作“/“是一个代价很高的操作，使用移位的操作将会更快和更有效123456如 int num = a / 4; int num = a / 8; 应该改为 int num = a &lt;&lt; 2; int num = a &lt;&lt; 3; 但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解 尽量确定StringBuffer的容量StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。1如：StringBuffer buffer = new StringBuffer(1000); 尽量早释放无用对象的引用大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。例如： 12345Public void test()&#123; Object obj = new Object(); …… Obj=null; &#125; 尽量避免使用二维数组二维数据占用的内存空间比一维数组多得多，大概10倍以上。 尽量避免使用split除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需 要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。 ArrayList &amp; LinkedList一 个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。 尽量使用System.arraycopy ()代替通过来循环复制数组System.arraycopy() 要比通过循环来复制数组快的多 尽量缓存经常使用的对象尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。 尽量避免非常大的内存分配有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。 慎用异常当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。如 果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。真正要花代价的是创建异常。幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就 抛出异常。异常是为异常的情况而设计的，使用时也应该牢记这一原则。]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
